# Unstoppable

## Challenge

There's a lending pool with a million DVT tokens in balance, offering flash loans for free.

If only there was a way to attack and stop the pool from offering flash loans ...

You start with 100 DVT tokens in balance.

## Solution

We assume that the `UnstoppableLender` contract is working before we attack it. In order to make its `flashLoan` function unusuable, we have to find a place where a `require` or `assert` will systematically fail.

We check that he first two `require` statements can only fail if the `borrowAmount` is outside the limits of the contract. Since this is not a systematic error we discard these two.

On the other hand, the last `require` is only asking to the borrower to pay back in the same transaction, which is the essence of a flash loan.

This leaves us with line 40 in the `flashLoan` function

```solidity
assert(poolBalance == balanceBefore);
```

How can we make these two values always different? We observe that `poolBalance` is a storage variable of the contract that represents the amount of DVT transferred to this contract via the `depositTokens` function. On the other hand `balanceBefore` is defined as

```solidity
uint256 balanceBefore = damnValuableToken.balanceOf(address(this));
```

which corresponds to the total amount of DVT tokens that this contract has.

The crucial point here is that the `UnstoppableLender` contract can actually accept transfers in two other ways. This can be done either by directly transfering tokens to this contract, or by using the `selfdestruct` method on a contract with DVT tokens pointing to this contract.

We will use the first method now, but we explain how to solve both issues. To transfer DVT funds using Hardhat, we just need to add the following lines in the file [`unstoppable.challenge.js`](../../test/unstoppable/unstoppable.challenge.js)

```javascript
it("Exploit", async function () {
  /** CODE YOUR EXPLOIT HERE */
})
```

## Solving the issue

As we said before, there are two possible entry points to send DVT tokens to the `UnstoppableLender` contract. On the one hand, the problem generated by directly transferring tokens to the contract can be solved using a `fallback` function. This function will be executed anytime the method executed from an external agent has a signature that does not correspond to any of the functions in the contract. In this case it would look like this

```solidity
fallback() external nonpayable {
    revert;
}
```

This is not enough to solve the vulnerability since for Solidity 0.8.0, we can still send funds to a contract without passing though this fallback function. This can be done using a `selfdestruct(address)` method ona different contract that we call `Attacker`. This method deletes `Attacker` from the blockchain and sends all its funds to the selected `address`. An example of this `Attacker` contract can be found [here](/Attacker.sol).

Therefore, to make the `UnstoppableLender` contract safe, we need to modify its logic. There are several possible solutions depending on what we want to achieve. If we just want to lend funds that are provided via the `depositTokens` function, we need to redefine some variables in the `flashLoan` function

```solidity
uint256 balanceBefore = poolBalance;
//
//
uint256 balanceAfter = poolBalance;

```

In this case the borrowers would necessarily need to transfer the funds back by calling the `depositTokens` function, otherwise the `poolBalance` variable would not be updated.

If we want to be able to lend any transferred token to this contract by any possible method and still keep track of the formally deposited tokens, we may create a function or modifier called `updatePoolBalance` that executes at he beginning of every function and updates the value of the variable `poolBalance` before making any transfers. This is a
